name                   = strict
file_extensions []     = strict;

__KEYWORDS    \= \b(create|throw|continue|break|try|do|method|and|or|in|is|from|downto|return|to|type|for|if|else|yield|isnt|not)(\s|\Z)
__OPERATORS   \= ([.+|\-()<>\[\]!=%*,]+)
__IDENTIFIER  \= ([a-zA-Z]+[a-zA-Z0-9_]*)
__TYPE_NAME   \= ([\w<>]+)
__BUILTIN \= (true|false|absent)

styles [] {
   .None : style {
      color = #000
      textmate_scope = none
   }

   .Comment : style {
      color = #111
      textmate_scope = comment
   }

   .Keyword : style {
      color = red
      textmate_scope = keyword
   }

   .Builtin : style {
      color = blue
      textmate_scope = constant
   }

   .Identifier : style {
      color = white
      textmate_scope = entity.name
   }


   .NameOfType : style {
      color = green
      textmate_scope = entity.name.type
   }

   .NameOfVariable : style {
      color = white
      textmate_scope = variable
   }

   .NameOfFunction : style {
      color = pink
      textmate_scope = entity.name.function
   }

   .NameOfParameter : style {
      color = white
      textmate_scope = variable.parameter
   }

   .FunctionCall : style {
      color = yellow
      textmate_scope = entity.name.function
   }

   .NumberLiteral : style {
      color = blue
      textmate_scope = constant.numeric
   }

   .Punctuation : style {
      color = orange
      textmate_scope = punctuation
   }

   .Operator : style {
      color = orange
      textmate_scope = punctuation
   }

   .TextLiteral : style {
      color = blue
      textmate_scope = string
   }

   .Illegal : style {
      color = white
      background_color = red
      textmate_scope = invalid
   }
}

contexts [] {
   TopLevelDeclarations : context {
      : include "MethodDeclaration";
      : include "Throws";
   }

   Code : context {
      : include "Statements";
      : include "Expressions";
   }


   Throws : context {
      : inline_push {
         regex \= (throws)(\s+)
         styles [] = .Keyword, .None;
         : eol_pop {
         }
         : pattern {
            regex \= $${__TYPE_NAME}
            styles [] = .NameOfType;
         }
         : pattern {
            regex \= (\,)
            styles [] = .None;
         }
      }
   }

   MethodDeclaration : context {
      : inline_push {
         regex \= (method)(\s+)$${__TYPE_NAME}(\s+)$${__IDENTIFIER}(\s*)(\()
         styles [] = .Keyword, .None, .NameOfType, .None, .NameOfFunction, .None, .Punctuation;
         : pop {
            regex \= (\))
            styles [] = .Punctuation;
         }
         : pattern {
            regex \= (\,)
            styles [] = .Punctuation;
         }
         : pattern {
            regex \= $${__TYPE_NAME}(\s+)(\w+)
            styles [] = .NameOfType, .None, .NameOfParameter;
         }
         : pattern {
            regex \= $${__TYPE_NAME}
            styles [] = .NameOfParameter;
         }
      }
      : pattern {
         regex \= (method)(\s+)$${__TYPE_NAME}(\s+)$${__IDENTIFIER}
         styles [] = .Keyword, .None, .NameOfType, .None, .NameOfFunction;
      }
      : pattern {
         regex \= (method)(\s+)$${__TYPE_NAME}
         styles [] = .Keyword, .None, .NameOfType;
      }

   }

   Statements : context {
      : include "Loops";
   }

   Loops : context {
      : include "ForEachLoop";
      : include "FromToLoop";
   }

   ForEachLoop : context {
      : inline_push {
         regex \=(for)(\s+)$${__IDENTIFIER}(\s+)(in)(\s+)
         styles [] = .Keyword, .None, .NameOfVariable, .None, .Keyword, .None;
         : pop {
            regex \= (do)
            styles [] = .Keyword;
         }
         : include "Code";
      }
   }

   FromToLoop : context {
      : inline_push {
         regex \=(for)(\s+)$${__IDENTIFIER}(\s+)(from)(\s+)
         styles [] = .Keyword, .None, .NameOfVariable, .None, .Keyword, .None;
         : pop {
            regex \= (do)
            styles [] = .Keyword;
         }
         : include "Code";
      }
   }

   Expressions : context {
      : include "Keyword";
      : include "ExpressionList";
      : include "Operator";
      : include "MethodCall";
      : include "Assignment";
      : include "Identifier";
      : include "NumberLiteral";
      : include "TextLiteral";
   }

   ExpressionList : context {
      : inline_push {
         regex \= (\()
         styles [] = .Punctuation;
         : pop {
            regex \= (\))
            styles [] = .Punctuation;
         }
         : include "ExpressionList" ;
         : pattern {
            regex \= (,)
            styles [] = .Punctuation;
         }
      }
   }

   Keyword : context {
     : pattern {
         regex \= $${__KEYWORDS}
         styles [] = .Keyword;
      }
   }

   Operator : context {
      : pattern {
         regex  \= $${__OPERATORS}
         styles [] = .Operator;
      }
   }

   Assignment : context {
      : pattern {
         regex \= $${__IDENTIFIER}(\s*)(\=)
         styles [] = .NameOfVariable, .None, .Punctuation;
      }
   }

   MethodCall : context {
      : inline_push {
         regex \= $${__IDENTIFIER}(\s*)(\()
         styles [] = .FunctionCall, .Punctuation, .Punctuation;
         : pop {
            regex \= (\))
            styles [] = .Punctuation;
         }
         : include "main" ;
         : pattern {
            regex \= (,)
            styles [] = .Punctuation;
         }
      }
   }

   Identifier : context {
      : pattern {
         regex \= $${__BUILTIN}
         styles [] = .Builtin;
      }
      : pattern {
         regex \= ([a-zA-Z]([a-zA-Z0-9]*))
         styles [] = .Identifier;
      }
   }

   NumberLiteral : context {
      : pattern {
         regex \= (\b\d+)
         styles [] = .NumberLiteral;
      }
   }

   TextLiteral : context {
      : inline_push {
         regex \= (")
         styles [] = .TextLiteral;
         : pop {
            regex \= (\")
            styles [] = .TextLiteral;
         }
         : pattern {
            regex \= (\\(?:\\|"))
            styles [] = .TextLiteral;
         }
         : pattern {
            regex \= ([^"\\]+)
            styles [] = .TextLiteral;
         }
      }
   }

   Comment : context {
      : pattern {
         regex          \= (//.*)
         styles []       = .Comment;
      }
      : inline_push {
         regex          \= (/\*)
         styles []       = .Comment;
         default_style   = .Comment
         : pop {
            regex       \= (\*/)
            styles []    = .Comment;
         }
      }
   }

   main : context {
      : include "TopLevelDeclarations";
      : include "Code";

      : pattern {
         regex          \= ([^\s])
         styles []       = .Illegal;
      }
   }
}

